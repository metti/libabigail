From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dodji Seketeli <dodji@seketeli.org>
Date: Fri, 4 Dec 2020 12:05:14 +0100
Subject: ir: Add better comments to types_have_similar_structure

	* src/abg-ir.cc (types_have_similar_structure): Arrays are also
	indirect types, just like pointers and references, for the purpose
	of the concept of "type similarity".  Add that to the introductory
	comment of the function.  Add some more misc comments throughout
	the code base.

Signed-off-by: Dodji Seketeli <dodji@redhat.com>
Signed-off-by: Matthias Maennich <maennich@google.com>
---
 src/abg-ir.cc | 16 +++++++++-------
 1 file changed, 9 insertions(+), 7 deletions(-)

diff --git a/src/abg-ir.cc b/src/abg-ir.cc
index 0b3739fa5a9c..34c2a0a6c43c 100644
--- a/src/abg-ir.cc
+++ b/src/abg-ir.cc
@@ -23633,10 +23633,10 @@ types_have_similar_structure(const type_base_sptr& first,
 ///
 /// typedef are resolved to their definitions; their names are ignored.
 ///
-/// Two indirect types (pointers or references) have similar structure
-/// if their underlying types are of the same kind and have the same
-/// name.  In the indirect types case, the size of the underlying type
-/// does not matter.
+/// Two indirect types (pointers, references or arrays) have similar
+/// structure if their underlying types are of the same kind and have
+/// the same name.  In the indirect types case, the size of the
+/// underlying type does not matter.
 ///
 /// Two direct types (i.e, non indirect) have a similar structure if
 /// they have the same kind, name and size.  Two class types have
@@ -23647,7 +23647,9 @@ types_have_similar_structure(const type_base_sptr& first,
 ///
 /// @param second the second type to consider.
 ///
-/// @param indirect_type whether to do an indirect comparison
+/// @param indirect_type if true, then consider @p first and @p
+/// second as being underlying types of indirect types.  Meaning that
+/// their size does'nt matter.
 ///
 /// @return true iff @p first and @p second have similar structures.
 bool
@@ -23676,7 +23678,7 @@ types_have_similar_structure(const type_base* first,
       const pointer_type_def* ty2 = is_pointer_type(second);
       return types_have_similar_structure(ty1->get_pointed_to_type(),
 					  ty2->get_pointed_to_type(),
-					  true);
+					  /*indirect_type=*/true);
     }
 
   // Peel off matching references.
@@ -23687,7 +23689,7 @@ types_have_similar_structure(const type_base* first,
 	return false;
       return types_have_similar_structure(ty1->get_pointed_to_type(),
 					  ty2->get_pointed_to_type(),
-					  true);
+					  /*indirect_type=*/true);
     }
 
   if (const type_decl* ty1 = is_type_decl(first))
